from collections import deque
from typing import *

#first opcode,second arg2,third arg1
vm_code = [ 0x20, 0xb9, 0x20, 0x04, 0x20, 0x08, 0x04, 0x10, 0x00, 0x04, 0x40, 0x00, 0x04, 0x20, 0x00, 0x04, 0x00, 0x20, 0x04, 0x00, 0x40, 0x04, 0x00, 0x10, 0x20, 0x96, 0x08, 0x20, 0x01, 0x40, 0x02, 0x04, 0x40, 0x20, 0x43, 0x01, 0x04, 0x01, 0x00, 0x20, 0x4f, 0x01, 0x04, 0x01, 0x00, 0x20, 0x52, 0x01, 0x04, 0x01, 0x00, 0x20, 0x52, 0x01, 0x04, 0x01, 0x00, 0x20, 0x45, 0x01, 0x04, 0x01, 0x00, 0x20, 0x43, 0x01, 0x04, 0x01, 0x00, 0x20, 0x54, 0x01, 0x04, 0x01, 0x00, 0x20, 0x21, 0x01, 0x04, 0x01, 0x00, 0x20, 0x20, 0x01, 0x04, 0x01, 0x00, 0x20, 0x59, 0x01, 0x04, 0x01, 0x00, 0x20, 0x6f, 0x01, 0x04, 0x01, 0x00, 0x20, 0x75, 0x01, 0x04, 0x01, 0x00, 0x20, 0x72, 0x01, 0x04, 0x01, 0x00, 0x20, 0x20, 0x01, 0x04, 0x01, 0x00, 0x20, 0x66, 0x01, 0x04, 0x01, 0x00, 0x20, 0x6c, 0x01, 0x04, 0x01, 0x00, 0x20, 0x61, 0x01, 0x04, 0x01, 0x00, 0x20, 0x67, 0x01, 0x04, 0x01, 0x00, 0x20, 0x3a, 0x01, 0x04, 0x01, 0x00, 0x20, 0x0a, 0x01, 0x04, 0x01, 0x00, 0x20, 0x14, 0x20, 0x20, 0x01, 0x10, 0x08, 0x01, 0x01, 0x20, 0x2f, 0x01, 0x20, 0x80, 0x20, 0x01, 0x01, 0x20, 0x20, 0x66, 0x01, 0x20, 0x81, 0x20, 0x01, 0x01, 0x20, 0x20, 0x6c, 0x01, 0x20, 0x82, 0x20, 0x01, 0x01, 0x20, 0x20, 0x61, 0x01, 0x20, 0x83, 0x20, 0x01, 0x01, 0x20, 0x20, 0x67, 0x01, 0x20, 0x84, 0x20, 0x01, 0x01, 0x20, 0x20, 0x00, 0x01, 0x20, 0x85, 0x20, 0x01, 0x01, 0x20, 0x20, 0x80, 0x10, 0x20, 0x00, 0x40, 0x08, 0x01, 0x02, 0x20, 0x00, 0x40, 0x02, 0x04, 0x40, 0x20, 0xff, 0x20, 0x20, 0x00, 0x10, 0x02, 0x01, 0x10, 0x08, 0x01, 0x10, 0x20, 0x00, 0x40, 0x02, 0x04, 0x40, 0x20, 0x00, 0x20, 0x02, 0x01, 0x20, 0x20, 0x01, 0x10, 0x08, 0x01, 0x01, 0x20, 0x00, 0x10, 0x08, 0x00, 0x20, 0x04, 0x10, 0x00, 0x04, 0x40, 0x00, 0x04, 0x20, 0x00, 0x20, 0x01, 0x40, 0x02, 0x04, 0x40, 0x20, 0x4b, 0x01, 0x04, 0x01, 0x00, 0x20, 0x45, 0x01, 0x04, 0x01, 0x00, 0x20, 0x59, 0x01, 0x04, 0x01, 0x00, 0x20, 0x3a, 0x01, 0x04, 0x01, 0x00, 0x20, 0x20, 0x01, 0x04, 0x01, 0x00, 0x20, 0x05, 0x20, 0x20, 0x01, 0x10, 0x08, 0x01, 0x01, 0x04, 0x00, 0x20, 0x04, 0x00, 0x40, 0x04, 0x00, 0x10, 0x04, 0x10, 0x00, 0x04, 0x40, 0x00, 0x04, 0x20, 0x00, 0x20, 0x30, 0x40, 0x20, 0x0b, 0x20, 0x20, 0x00, 0x10, 0x08, 0x01, 0x10, 0x04, 0x00, 0x20, 0x04, 0x00, 0x40, 0x04, 0x00, 0x10, 0x20, 0x02, 0x08, 0x20, 0x01, 0x40, 0x02, 0x04, 0x40, 0x20, 0x49, 0x01, 0x04, 0x01, 0x00, 0x20, 0x4e, 0x01, 0x04, 0x01, 0x00, 0x20, 0x43, 0x01, 0x04, 0x01, 0x00, 0x20, 0x4f, 0x01, 0x04, 0x01, 0x00, 0x20, 0x52, 0x01, 0x04, 0x01, 0x00, 0x20, 0x52, 0x01, 0x04, 0x01, 0x00, 0x20, 0x45, 0x01, 0x04, 0x01, 0x00, 0x20, 0x43, 0x01, 0x04, 0x01, 0x00, 0x20, 0x54, 0x01, 0x04, 0x01, 0x00, 0x20, 0x21, 0x01, 0x04, 0x01, 0x00, 0x20, 0x0a, 0x01, 0x04, 0x01, 0x00, 0x20, 0x0b, 0x20, 0x20, 0x01, 0x10, 0x08, 0x01, 0x01, 0x20, 0x01, 0x10, 0x08, 0x00, 0x20, 0x20, 0x30, 0x10, 0x20, 0x75, 0x40, 0x20, 0x09, 0x20, 0x20, 0x02, 0x01, 0x02, 0x08, 0x01, 0x04, 0x01, 0x00, 0x20, 0xa3, 0x08, 0x20, 0x00, 0x20, 0x10, 0x20, 0x01, 0x20, 0x09, 0x01, 0x80, 0x01, 0x04, 0x20, 0x79, 0x01, 0x80, 0x01, 0x03, 0x02, 0x20, 0x10, 0x02, 0x20, 0x40, 0x20, 0xff, 0x01, 0x02, 0x01, 0x10, 0x02, 0x01, 0x40, 0x04, 0x10, 0x00, 0x04, 0x40, 0x00, 0x40, 0x10, 0x10, 0x40, 0x40, 0x40, 0x10, 0x40, 0x10, 0x04, 0x00, 0x40, 0x04, 0x00, 0x10, 0x20, 0xb7, 0x01, 0x80, 0x01, 0x08, 0x20, 0xff, 0x01, 0x02, 0x01, 0x20, 0x20, 0x00, 0x01, 0x10, 0x01, 0x20, 0x20, 0xa5, 0x01, 0x80, 0x01, 0x08, 0x04, 0x20, 0x01, 0x04, 0x00, 0x08, 0x20, 0x8d, 0x01, 0x20, 0x73, 0x20, 0x01, 0x01, 0x20, 0x20, 0x23, 0x01, 0x20, 0x74, 0x20, 0x01, 0x01, 0x20, 0x20, 0x16, 0x01, 0x20, 0x75, 0x20, 0x01, 0x01, 0x20, 0x20, 0xd2, 0x01, 0x20, 0x76, 0x20, 0x01, 0x01, 0x20, 0x20, 0x77, 0x01, 0x20, 0x77, 0x20, 0x01, 0x01, 0x20, 0x20, 0x4f, 0x01, 0x20, 0x78, 0x20, 0x01, 0x01, 0x20, 0x20, 0x6a, 0x01, 0x20, 0x79, 0x20, 0x01, 0x01, 0x20, 0x20, 0x73, 0x01, 0x20, 0x7a, 0x20, 0x01, 0x01, 0x20, 0x20, 0x93, 0x01, 0x20, 0x7b, 0x20, 0x01, 0x01, 0x20, 0x20, 0x7f, 0x01, 0x20, 0x7c, 0x20, 0x01, 0x01, 0x20, 0x20, 0x79, 0x01, 0x20, 0x7d, 0x20, 0x01, 0x01, 0x20, 0x20, 0x59, 0x08 ]

# a = 0
# b = 0
# c = 0
# d = 0
# s = 0
# i = 1
# f = 0
#                a      b      c     d     s     i     f
# register = {0x10:0,0x40:0,0x20:0,0x1:0,0x4:0,0x8:1,0x2:0}
reverse_register = {0x10:'a',0x40:'b',0x20:'c',0x1:'d',0x4:'s',0x8:'i',0x2:'f',0x0:None}
op_code = {0x20:'IMM',0x02:'ADD',0x04:'STK',0x01:'STM',0x40:'LDM',0x10:'CMP',0x08:'SYS',0x80:'JMP'}


class vm_memory:
   def __init__(self,vm_mem_size: int) -> None:
      self.vm_memory: List[Union[int,str]] = [0] * vm_mem_size 

   def write_vm_memory(self,position: int,data: Union[int,str]) -> None:
      self.vm_memory[position] = data

   def read_vm_memory(self,position: int)->Union[int,str]:
      return self.vm_memory[position]
   
   def read_entire_vm_memory(self) -> List[Union[int,str]]:
      return self.vm_memory


class vm_register:
   def __init__(self,a: int,b: int,c: int,d: int,s: int,i: int,f: int):
      self.a_hex = a
      self.b_hex = b
      self.c_hex = c
      self.d_hex = d
      self.s_hex = s
      self.i_hex = i
      self.f_hex = f
      self.register: dict[int,int]= {self.a_hex:0,self.b_hex:0,self.c_hex: 0, self.d_hex: 0, self.s_hex: 0, self.i_hex: 1,self.f_hex: 0}
      self.reverse_register = {self.a_hex: "a",self.b_hex: "b",self.c_hex: "c",self.d_hex: "d",self.s_hex: "s",self.i_hex: "i",self.f_hex:"f"}
   
   def write_register(self,register: int,value: int) -> None:
      self.register[register] = value
      return

   def read_register(self,register: int) -> Union[int,str]:
      reg_value = self.register[register]
      return reg_value

class vm_stack:
   def  __init__(self,register: vm_register):
      self.stack: deque[int] = deque()
      self.register = register

   def push_stack(self,register:int) -> None:
      self.stack.append(register)

   def pop_stack(self,register:int) -> None:
      self.register.write_register(register,self.stack.pop())


class disassemble_yan_85:
   """
   Get all the hex code for yan_85 instructions for that respective binary
   """
   def __init__(self,imm: int,add: int,stk: int,stm: int,ldm: int,cmp: int,jmp: int,sys :int,byte_code: list[int],registers: vm_register,virtual_memory: vm_memory,virtual_stack: vm_stack):
      self.instructions = {"IMM":imm,"ADD":add,"STK":stk,"STM":stm,"LDM":ldm,"CMP":cmp,"JMP":jmp,"SYS":sys}
      self.byte_code = byte_code
      self.register = registers
      self.vm_mem = virtual_memory
      self.vm_stack = virtual_stack

   def translate(self) -> None:
      #while True
      for _ in range(10):
         three_bytes = self.byte_code[self.register.register[self.register.i_hex]*3-3:self.register.register[self.register.i_hex]*3]
         three_translated = []
         for i in range(len(three_bytes)):
            match i:
               case 0:
                  current = list(self.instructions.keys())[list(self.instructions.values()).index(three_bytes[i])]
               case 1: 
                  current = hex(three_bytes[i])
               case 2:
                  current = hex(three_bytes[i])
            three_translated.append(current)
         tmp = three_translated[1]
         three_translated[1] = three_translated[2]
         three_translated[2] = tmp

         print(f"[V] a:{hex(self.register.register[self.register.a_hex])} b:{hex(self.register.register[self.register.b_hex])} c:{hex(self.register.register[self.register.c_hex])} d:{hex(self.register.register[self.register.d_hex])} s:{hex(self.register.register[self.register.s_hex])} i:{hex(self.register.register[self.register.i_hex])} f:{hex(self.register.register[self.register.f_hex])}")
         print(f"[I] op:{hex(three_bytes[0])} arg1:{hex(three_bytes[2])} arg2:{hex(three_bytes[1])}")

         match three_translated[0]:
            case "IMM":
               self.register.write_register(three_bytes[2],three_bytes[1])
               print(f"[s] {three_translated[0]} {self.register.reverse_register.get(three_bytes[2])} = {three_translated[2]}")
            case "ADD":
               add_res = self.register.register[three_bytes[2]] + self.register.register[three_bytes[1]]
               self.register.write_register(three_bytes[2],add_res)
               print(f"[s] {three_translated[0]} {self.register.reverse_register.get(three_bytes[2])}  {three_translated[2]}")
            case "STK":
               print(f"[s] {three_translated[0]} {self.register.reverse_register.get(three_bytes[2])} {self.register.reverse_register.get(three_bytes[1])}")
               if three_bytes[1] != 0x0:
                  reg_value = self.register.register[three_bytes[1]]
                  self.vm_stack.push_stack(reg_value)
                  print(f"[s] ... pushing {self.register.reverse_register[three_bytes[1]]}")
               if three_bytes[2] != 0x0:
                  reg_value = self.register.register[three_bytes[2]]
                  self.vm_stack.pop_stack(three_bytes[2])
                  print(f"[s] ... popping {self.register.reverse_register[three_bytes[2]]}")
            case "STM":
               print(f"[s] {three_translated[0]} *{self.register.reverse_register[three_bytes[2]]} = {self.register.reverse_register[three_bytes[1]]}")
               self.vm_mem.write_vm_memory(self.register.register[three_bytes[2]],self.register.register[three_bytes[1]])
               # print(f"[s] current memory layout: {self.vm_mem.read_entire_vm_memory()}")
               


         self.register.register[self.register.i_hex] += 1


reg_class = vm_register(0x10,0x40,0x20,0x1,0x4,0x8,0x2)
virutal_mem = vm_memory(1000)
virutal_stack = vm_stack(reg_class)
yan_85_dis = disassemble_yan_85(0x20,0x02,0x04,0x01,0x40,0x10,0x08,0x80,vm_code,reg_class,virutal_mem,virutal_stack)

yan_85_dis.translate()

#Todo: change for loop to while loop so that the vm_codes are not read in order but by the instruction pointer aka i
#Todo: create virtual memory[just an array xd] to be loaded into
#Todo: maybe refactor all of this into subclasses and shit to make it clearer
#Todo: add the remaining instructions
